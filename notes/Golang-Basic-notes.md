# 1 安装GO

## 1.1 安装GO运行环境

```
https://go.dev/
https://golang.google.cn/
```



![image-20240502173600662](./../images/image-20240502173600662.png)



### 1.1.1 基础知识扫盲

```bash
#win有两个版本msi版本不需要修改PATH路径
命令行输入go:
	在当前OS环境中查找命令（可执行文件），但目录太多不方便使用，所以依赖于PATH指定的路径。操作系统会去PATH指定的所有目录找go，找不到报错。windows优先再当前目录，找不到才去找PATH。

环境变量: 操作系统运行环境中提前定义好的变量
	PATH：如果你在命令行输入一端字符，shell解析它，被解释为可执行的文件（命令）：
	GOROOT: GO的安装路径
	GOPATH: 当前用户家目录 $HOME/go (第三方包安装路径)
	PATH: %USERPROFILE%/go/bin = GOPATH + bin = /root/go/bin
		win中的%USERPROFILE% = 家目录
		bin = binary 二进制/编译完成的可执行文件
		GOROOT + bin
	pkg目录:缓存第三方包文件bin日录:第三方包通过go install命令下载并编译好的可执行文件的存放
	go install命令:下载第三方包到$GOPATH/go/下面的缓存包文件们到该目录，编译好可执行文件放到$GOPATH/go/bin
	go get命令:下载第三方包到$GOPATH/g0/下面的缓存包文件们到该目录，以后编程用这些包


#查看win变量
win + r -- cmd -- 输入set

Path=C:\Program Files\Java\jdk1.8.0_281\bin;C:\Program Files (x86)\Common Files\Oracle\Java\javapath;C:\Program Files\Java\jdk-1.8\bin;D:\VM17.0\bin\;C:\Program Files (x86)\Common Files\Intel\Shared Libraries\redist\intel64\compiler;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\dotnet\;D:\XshellXftp\Xshell\;D:\XshellXftp\Xftp\;E:\Xmanager\;C:\Users\50569\AppData\Local\Programs\Python\Python311\Scripts\;C:\Users\50569\AppData\Local\Programs\Python\Python311\;C:\Users\50569\AppData\Local\Microsoft\WindowsApps;;D:\Pycharm\PyCharm Community Edition 2023.2.1\bin;;E:\vscode\Microsoft VS Code\bin
```



#### 1.1.1.1 通用添加环境变量mac/linux

```bash
#默认
GOPROXY缺省是https://proxy.golang.org,direct
#go1.16之后不用配置
go env -w GO111MODULE=On
#Go Module代理加速仓库服务
go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/

#验证
go env 
```



### 1.1.2 win安装 

#### 1.1.2.1 配置PATH路径

```bash
#使用msi版本的安装方法会自动配置PATH --> 下载包 --> 然后解压到指定的目录
此电脑--右击--高级系统设置
```

![image-20240502175546498](./../images/image-20240502175546498.png)



**一个是当前用户PATH/一个是全局PATH**

![image-20240502175704533](./../images/image-20240502175704533.png)



![image-20240502180526299](./../images/image-20240502180526299.png)



#### 1.1.2.1 windows配置方法

![image-20240502193027332](./../images/image-20240502193027332.png)







### 1.1.3 linux安装

#### 1.1.3.1 解包

```bash
wget https://dl.google.com/go/go1.22.2.linux-amd64.tar.gz
tar xvf go1.22.2.linux-amd64.tar.gz -C /usr/local
```

#### 1.1.3.2 设置环境变量

```bash
export PATH:$PATH:/usr/loacl/go/bin/
export GOPROXY=https://mirrors.aliyun.com/goproxy/
export GOROOT=<go安装路径>
export GOPATH=$HOME/go
export PATH=$PATH:$GOROOT/bin/  	 #go程序在这里
export PATH=$PATH:$GOPATH/go/bin/	 #三方依赖默认存在这里
#验证
go env 
go version
```



#### 1.1.3.3 设置环境变量 七牛云

```
Go 1.13 及以上（推荐）

打开你的终端并执行

$ go env -w GO111MODULE=on
$ go env -w GOPROXY=https://goproxy.cn,direct
完成。

macOS 或 Linux

打开你的终端并执行

$ export GO111MODULE=on
$ export GOPROXY=https://goproxy.cn
或者

$ echo "export GO111MODULE=on" >> ~/.profile
$ echo "export GOPROXY=https://goproxy.cn" >> ~/.profile
$ source ~/.profile
完成。

Windows

打开你的 PowerShell 并执行

C:\> $env:GO111MODULE = "on"
C:\> $env:GOPROXY = "https://goproxy.cn"
或者

1. 打开“开始”并搜索“env”
2. 选择“编辑系统环境变量”
3. 点击“环境变量…”按钮
4. 在“<你的用户名> 的用户变量”章节下（上半部分）
5. 点击“新建…”按钮
6. 选择“变量名”输入框并输入“GO111MODULE”
7. 选择“变量值”输入框并输入“on”
8. 点击“确定”按钮
9. 点击“新建…”按钮
10. 选择“变量名”输入框并输入“GOPROXY”
11. 选择“变量值”输入框并输入“https://goproxy.cn”
12. 点击“确定”按钮
```



## 1.2 安装GO开发环境

```c
商业：Goland
免费：VSCode（JS ES TS开发第一工具） go语言/伟哥推荐 
     https://code.visualstudio.com/Download
```

### 1.2.1 安装Vscode

无脑安装向导

![image-20240502203403523](./../images/image-20240502203403523.png)

#### 1.2.1.1 Vscod配置

```bash
#直接在扩展中搜索 go插件
```

新建项目（开发根目录）

![image-20240502204449841](./../images/image-20240502204449841.png)



![image-20240502204714113](./../images/image-20240502204714113.png)



![image-20240502204824269](./../images/image-20240502204824269.png)



![image-20240502204928434](./../images/image-20240502204928434.png)



```bash
#安装完go会自动弹出强依赖也要安装
install all = 调试编译开发全部安装
```

![image-20240502205227993](./../images/image-20240502205227993.png)

```
gopls和glv最重要一定要确保他俩安装成功
go install 第三方包下载到 GOPATH指定下目录下，编译好可执行文件放到GOPATH/go/bin/
	下载第三方包 -- 编译 
go get 
	直接下载到GOPATH指定下目录下，以后编程用这些
```

![image-20240502210547739](./../images/image-20240502210547739.png)

![image-20240502205435145](./../images/image-20240502205435145.png)

```bash
#vscode 命令行
ctrl + j
```

![image-20240502211134462](./../images/image-20240502211134462.png)



**如果下载失败尝试手动安装 或者更换GOPROXY的代理地址**

```bash
#官网地址
https://pkg.go.dev/golang.org/x/tools/gopls
go clean -modcache

#必须安装
go install -v github.com/go-delve/delve/cmd/dlv@latest
go install -v golang.org/x/tools/gopls@latest
#不是必须，代码语法检测
go install -v honnef.co/go/tools/cmd/staticcheck@latest
```

**安装完检查**

![image-20240502213629105](./../images/image-20240502213629105.png)



#### 1.2.1.2 hello-word

```go
package main

import "fmt"

func main() {
	fmt.Println("hello-word")
}

//运行
go run main.go

//调试Vscode  F5(自动保存+编译+调试)
如果按 F5 报错
//确保在项目的根目录 在TERMINAL输入 go mod init www.zed.org
Build Error: go build -o c:\Users\50569\Desktop\golang\project\test\__debug_bin3602295647.exe -gcflags all=-N -l .
go: go.mod file not found in current directory or any parent directory; see 'go help modules' (exit status 1)
```



会生成一个go mod文件

![image-20240502215651754](./../images/image-20240502215651754.png)



#### 优化配置

![image-20240502220045800](./../images/image-20240502220045800.png)

![image-20240502220120961](./../images/image-20240502220120961.png)



**安装插件** 

outline map

提高代码阅读效率

curl + 左键

![image-20240502220313700](./../images/image-20240502220313700.png)



postfix 补全代码

![image-20240502220853938](./../images/image-20240502220853938.png)





# 2 初识GO语言

## 2.1 GO命令

```go
go install  //下载第三方包到$GOPATH/g0/下面的缓存包文件们到该目录，编译好可执行文件放到$GOPATH/go/bin
go get 		//下载第三方包到SGOPATH/go下面的缓存包文件们到该目录，以后编程用这些包。如果开启了go模块，包依赖记录在go.mod中
	-u 更新包
go mod		//包管理
	go mod init <name>
	go mod tidy   //扫描当前项目，把go.mod文件中不依赖的第三方包删除，也可以把依赖的第三方包加入

go env
go version
go build 	 //编译
	-o 指定文件
go run		 //编译+运行

fmt 自动格式化代码  gols自动支持
```



## 2.2 项目结构

官方没有提供布局方案

![image-20240503171323133](./../images/image-20240503171323133.png)

## 2.3 计算机基础



![image-20240503172926564](./../images/image-20240503172926564.png)



```
冯诺依曼体系五大部件
	CPU:
	运算器
		一般给的一个任务，cpu要花几个震荡周期完成。主频越高越好
		假设3个滴答完成一次计算，请问频率高、低哪个省时间?主频越高越好，但是频率有天花板，所以上多核
	控制器
总线Bus：数据总线、控制总线 
存储器Memory:内存，掉电丢失，速度快
	运行内存:掉电丢失的芯片
	内部存储内存:相当于掉电不丢失的硬盘
	线性编地： 类似于门牌号对应一个内存地址 102 103 看下图
	
	
输入设备Input:数据输入
输出设备output:
输入输出设备不能和CPU直接打交道，CPU必须通过和内存交互进行数据交换。因为cpu中没有大量存储的空间。
	寄存器：为了本次计算所需数据服务
	缓存：cache（为了加速计算，预读取指令）Mb
	CPU亲缘性 避免CPU切换无法充分利用缓存
		1、2KB、3多核共享缓存
显卡：数字信号输入给显卡，显卡输出到显示器 
主板：骨架、神经系统

芯片组：
时钟振荡器
	脉冲信号，触发数字电路工作，频率越快CPU越快
	所有的数字设备都要利用产生的脉冲信号工作
	CPU运行频率是最高的3.xGhz
	
运行速度
CPU -- 内存（TB） 
IO设备，相对内存很漫 硬盘(PB)  固态 相对内存都特别慢

内存快但是掉电丢失 成本高
硬盘慢，但是可以持久化数据

除非有必要尽量在内存中读写，可以提高性能

程序向CPU发送指令  CPU找内存要数据 把需要的数据提前加载的内存中的cache中
```

![image-20240503191110646](./../images/image-20240503191110646.png)

**CPU并不直接从速度很慢的I0设备上直接读取数据，CPU可以从较慢的内存中读取数据到CPU的寄存器上运算器**
CPU计算的结果也会写入到内存，而不是写入到I0设备上



强类型语言

必须编译



弱类型  python  shell

强类型  C GO java

- 数据声明必须指定明确类型

- 不支持隐式类型转换，类型转换必须强制

- 代码编译成本地可执行代码

- 不需要虚拟机来运行
- 支持垃圾回收

### 不会写作业，刚开始，不要看答案，不会写，用中文写思想逻辑







# 3 GO基础语法

## 3.1 注释

```go
// 多行注释
/*
	a
	b
	a b c
*/


// TODO： 未完成任务
// NOTE： 请注意
// Deprecated： 告诉别人已经废弃了
// 一行一句代码

package main

import "fmt"

func main() {
	fmt.Println("lixijun")
	// TODO 未完成
}

```

![image-20240503202221685](./../images/image-20240503202221685.png)



## 3.2 命名规范

```bash
#大驼峰 如果要在包内外可见，就采用大驼峰命名
UserName
#小驼峰 如果只在包内可用，就采用小驼峰命名
userName
#sank
user_name

#条件变量、循环变量可以是单个字母或单个单词，Go倾向于使用单个字母。Go建议使用重短小

#常量用驼峰
在其他语言中，常量多使用全大写加下划线的命名方式，Go语言没有这个要求
对约定俗成的全大写，例如PI

函数/方法的参数、返回值应是单个单词或单个字母、函数可以是多个单词命名、类型可以是多个单词命名

方法由于调用时会绑定类型，所以可以考虑使用单个单词
包以小写单个单词命名包名应该和导入路径的最后一段路径保持一致
接口优先采用单个单词命名一般加er后缀。Go语言推荐尽量定义小接口，接口也可以组合
```



## 3.3 关键字

```bash
https:/lgolang.google.cn/ref/spec
#不能乱改
```

Go自己要用的

| 序号 | 关键字        | 说明                                                 |
| ---- | ------------- | ---------------------------------------------------- |
| 1    | `break`       | 用于终止最近的 `for` 或 `switch` 语句。              |
| 2    | `case`        | 用于定义 `switch` 语句的一个分支。                   |
| 3    | `chan`        | 用于声明通道，通道是一种允许并发程序之间通信的类型。 |
| 4    | `const`       | 用于声明常量。                                       |
| 5    | `continue`    | 跳过当前循环的剩余代码，直接开始下一次循环。         |
| 6    | `default`     | 用于定义 `switch` 语句中的默认分支。                 |
| 7    | `defer`       | 用于安排一个函数在调用它的函数退出前执行。           |
| 8    | `else`        | 用于定义 `if` 语句的“否则”分支。                     |
| 9    | `fallthrough` | 用于 `switch` 语句中，表示继续执行下一个 `case`。    |
| 10   | `for`         | 用于创建循环。                                       |
| 11   | `func`        | 用于声明函数。                                       |
| 12   | `go`          | 用于启动一个新的并发线程，称为 goroutine。           |
| 13   | `goto`        | 跳转到程序中的指定行。                               |
| 14   | `if`          | 用于执行条件判断。                                   |
| 15   | `import`      | 用于导入其他包。                                     |
| 16   | `interface`   | 用于定义接口。                                       |
| 17   | `map`         | 用于声明映射类型。                                   |
| 18   | `package`     | 用于定义包。                                         |
| 19   | `range`       | 用于迭代数组、切片、映射和通道。                     |
| 20   | `return`      | 用于从函数返回。                                     |
| 21   | `select`      | 用于创建多个通道操作的并发形式。                     |
| 22   | `struct`      | 用于定义结构体。                                     |
| 23   | `switch`      | 用于执行多个 `case` 的条件分支选择。                 |
| 24   | `type`        | 用于定义类型。                                       |
| 25   | `var`         | 用于声明变量。                                       |



## 3.4 预定义标识符

```bash
https://golang.google.cn/ref/spec#Predeclared identifiers
#可以但别
```



| 标识符       | 说明                                                 |
| ------------ | ---------------------------------------------------- |
| `bool`       | 布尔类型，表示真或假。                               |
| `byte`       | 8位的整数，代表一个ASCII码。                         |
| `complex64`  | 复数类型，由两个32位浮点数表示实部和虚部。           |
| `complex128` | 复数类型，由两个64位浮点数表示实部和虚部。           |
| `error`      | 错误类型，用于错误处理。                             |
| `float32`    | 32位浮点数。                                         |
| `float64`    | 64位浮点数。                                         |
| `int`        | 普通整数，大小取决于运行环境的架构（32位或64位）。   |
| `int8`       | 8位整数。                                            |
| `int16`      | 16位整数。                                           |
| `int32`      | 32位整数。                                           |
| `int64`      | 64位整数。                                           |
| `rune`       | 代表一个Unicode码点的整数类型。                      |
| `string`     | 字符串类型，由一系列字节组成。                       |
| `uint`       | 无符号整数，大小取决于运行环境的架构（32位或64位）。 |
| `uint8`      | 8位无符号整数。                                      |
| `uint16`     | 16位无符号整数。                                     |
| `uint32`     | 32位无符号整数。                                     |
| `uint64`     | 64位无符号整数。                                     |
| `uintptr`    | 无符号整数，用于存储指针的二进制表示。               |



## 3.5 内置函数

| 标识符    | 说明                                 |
| --------- | ------------------------------------ |
| `make`    | 用于创建切片、映射和通道。           |
| `new`     | 用于分配一个类型的新实例。           |
| `len`     | 获取字符串、切片、映射或通道的长度。 |
| `cap`     | 获取切片或通道的容量。               |
| `append`  | 用于追加元素到切片。                 |
| `copy`    | 用于复制切片内容。                   |
| `close`   | 关闭一个通道。                       |
| `complex` | 创建一个复数。                       |
| `real`    | 返回复数的实部。                     |
| `imag`    | 返回复数的虚部。                     |
| `panic`   | 触发一个运行时恐慌。                 |
| `recover` | 用于从恐慌中恢复。                   |





## 3.6 标识符

- 一个名字，本质上是个字符串，用来指代一个值
- 只能是大小写字母、数字、下划线，也可以是Unicode字符
- 不能以数字开头
- 不能是Go语言的关键字
- 尽量不要使用“预定义标识符"，否则后果难料
- 大小写敏感

**建议**

不要使用中文非必要不要使用拼音，尽量遵守上面的命名规范，或形成一套行之有效的命名规则。



```bash
#什么是标识符
a = 100  a指代100, a就是就是代表100的名称，a = 100 的标识符
100是数字，常量，不可变的值  字面常量
100+1=101，100还是那个100，1还是那个1，101就是101
并没有修改 100 也没有修改1 而是出现了一个新的值

 100 + 1  100 + 2 100 + 3 替换成  a + 1  a + 2  a + 3 


如果
a = 200 说明a背后指代的值可以变化（a变了）；所以可以变化的指代值的标识符，称为变量标识符
如果说a的指代一旦关联，不可变，a这个标识符指代的值不能改变了，称为常量标识符
```



## 3.7 字面常量

它是值，不是标识符，但本身就是常量，不能被修改。

Go语言中，boolean、rune、integer、float、complex、string都是字面常量。其中，rune（int32）、integer、flaat、complex常量被称为数值常量。

```
数字1就是1，数字100就是100，两个加起来=101 但是来的1 和 100 并没有改变


"ab" + "c" = "abc"  ab还是以前的ab，c也是c 得出一个新的值是 abc (字符串类型)

‘ab’  ‘c’  （字符类型）只能放一个字符

true false iota

var 变量名
const常量名= 初值 常量必须在定义是直接赋初值

const c ="abc“
const d int = 100 //字面常量100关联
const e uint8 = 100 // 右边无类型常量100 ，和左边有类型常量uint8e关联
// int 8bits -- 1bytes -128~127 -- 0~255

const d  = ”100“ // 类型推导 根据右边推断左边
const d  = 100   // 默认推导为 int   int 和 uint8两码事

如果左边没有指定类型，会根据右边的默认类型推导出他的类型。
字面常量本身是有类型的，
```

以上字面常量在Go中也被称为无类型常量untyped constant.无类型常量的缺省类型为bool、rune、int、float64、complex128或字符串,

注意:Go语言的常量定义，必须是能在编译器就要完全确定其值，所以，值只能使用字面常量。这和其他语言不同!例如，在其他语言中，可以用常量标识符定义一个数组，因为常量标识符保证数组地址不变，而其内元素可以变化。但是Go根本不允许这样做。



```go
在go语言中值有类型之分 
	无类型常量untyped constant
		无类型并不不是真的没有，而是有默认值；
		const a int = 101 // 正常写法
		const(   		  // 推导写法，根据右边数值的缺省类型推导出左边标识符的类型
			b = "abc"
			c = 100
		)

const a = "abc" 赋值语句
// 右边是无类型常量，它的缺省类型是string，左边a没有指定类型，a会进行类型推导，会依赖右边的类型，所以a被推测为string类型
```



## 3.8 iota

```
iota 批量定义常量
是从成批的第一个常量开始计数
```

![image-20240503214621912](./../images/image-20240503214621912.png)





![image-20240503214756552](./../images/image-20240503214756552.png)

![image-20240503215846825](./../images/image-20240503215846825.png)

![image-20240503215415969](./../images/image-20240503215415969.png)

范例：

```go
// 单独iota 从0开始
const a = iota	// 0 
const b = iota	// 0 
```



```go
// 批量定义
const (
	SUN = iota // 0
	MON = iota // 1
	TUE = iota // 2	
)

const (
	SUN = iota // 0
	MON
	TUE
)

const(
	a = iota // 0
	b 		// 1
    c		// 2
    _		// 按道理是3，但是丢弃了
    d		// 4
    e = 10  // 10
    f		// 10
    g = iota// 7
    h		// 8

)


const(
	m = 0          // iota = 0 * 2
    n			   // iota = 1 * 2
    a = 2 * iota   // iota = 2 * 2
    b			   // iota = 3 * 2
    c        	   // iota = 4 * 2
    d			   // iota = 5 * 2
)

a b c d 分别是 4 6 8 10
```



```bash
其他语言
const a = [1,2]

在go语言中，常量不可以定义数组
var a = [3]int{100,200,300}  // 代表定义变量 指定数组中有三个元素，而且必须是int类型

const a = [2]int{100,200}  报错
{}可以在花括号写元素
Go语言的常量定义，必须是能在编译器就要完全确定其值，所以，值只能使用字面常量。(必须给定值而且不能变)
但是数组的值可以更换，违背了const，所以在go中只能定义为var

其他语言是按照开头只要开头指向的内存地址不变那么就可以定义为常量

```

![image-20240503224052696](./../images/image-20240503224052696.png)



## 3.9 常量

```
cpu要使用的数值都要放在内存里面，因为磁盘太慢了。
“abc” 可以直接使用，但是如果是100个字符每次都用手敲很麻烦，所以我们可以给100个字符 起一个名字标识符
a = "100个字符" 后续使用我们用a指代100个字符。
“100” 是我给定的值 是我写出来的值 = 字面常量
我给定的值 计算机拿去运算比如 a + 1 = 101  并不会改变我们原来a的值  而是诞生了一个新的值
我可以给 a 这个标识符赋值 让他代表 100 这个字面常量

如果a的指代可以变化=变量
如果a的指代不可以变化 = 常量 但也可能是a有类型要求，同类型可以再次赋值=变量


如果不可以
	a有类型要求，不可以改变类型，同类型可以再次赋值，
	a是变量a就是不可以再被赋值，a和第一个赋给它的值之间的联系不可改变，a称为常量标识符
	
	
在其他语言中
	const a = [11,22]
	const a = [11,22,33]
	const a = [1231]
	可以这样玩，因为a指向内存中的数组开头的地址没变
	
在GO语言中
	const a = [2]int{1,2}
	必须指定数组的长度，但数组中的值可以变，长度不能变，因此不能被定义为常量。
	数组好比是一个容器 里面可以存放多个元素，元素可以变。可变就不能定义为常量
```



定义：

```ABAP
常量:标识符的指向的值一旦建立，不可改变，要求定义是必须建立关联
变量:标识符的指向的值建立后，可以改变
	1类型也可以变，往往动态语言JS、Python，举例a=100，a="abc",a=[1,2,3]
	2只能同类型可变
```



## 3.10 变量



```go
func main(){
	var a = 100
		a = 200
}

func main(){
	var a  		// 错误 因为GO是强类型语言，需要定义类型，但右边没有字面常量，无法根据默认类型推导a的类型
	var a int   // 正确 虽然没有赋值但是给定了类型。 GO特性 零值可用
    const b int // 错误 常量没有零值可用
    var a = 100 // 重复定义 不可以
}


常量可以批量定义，因为他会继承上一个赋值语句，可以进行类型推导。
变量批量定义必须要指定类型，因为它可以为空，为空就不能推导，不能确定类型，就报错哦。

var a int , b int // 错误
var a,b int // 可以 如果要写在一行，必须同类型，并且在最后指定类型
var a,b int = 100,200 //正确 要一起赋值
var(
	a int 
    b int 
)
```

![image-20240504164143982](./../images/image-20240504164143982.png)

### 3.10.1 短格式变量

```go
func main(){
	a := 100 // 短格式 变量定义 = 定义了变量标识符a 右边可以推导出类型 a 的类型
    a,b，c := 100,"avc".'d'// 短格式批量定义，依次对应推导   定义 赋值 推导
    
    a,b = b,c // 纯粹的赋值 没有类型推导  要注意类型，类型不同会报错
}

              	      // 短格式只能写在func中，不能再全局中定义 //


package main
func main() {
	var a,b = 100,200
	a:=123     // 这样显示重复定义
	c,d := 300,400
	var t = "lxj"
	t,f := "aolgei",123 // 这样就忽略了重复赋值，但类型必须一样，go给自己挖坑了属于是
	println(a,b)
	println(c,d,t,f)
}



// 定义 + 赋值
var a int = 100
// 定义 + 赋值 + 类型推导
	b := 200
// 存粹的赋值
	c = b


// 交换赋值
package main
import "fmt"

func main() {
	var a,b int = 100,200
	c,d := 123,456
	a,b = c,d  // 类型不匹配无法交换
	fmt.Println(a,b,c,d)
	var (
	 m = 1
	 n = 2
	)
	m,n = n,m // 赋值语句 = 从右往左执行，右边先定格
	2 1   2 1
	fmt.Println(m,n)

	// 其他语言交换变量
	tmp := m        
	 1
	m = n 
	2
	n = tmp 
	1
}

```

![image-20240504172006960](./../images/image-20240504172006960.png)



**注意：**

```
变量的定义赋值 从右往左边，右边的值先定下来，依次给左边赋值

如下：
	m = 111 
	n = 222
	
	m,n = n , m 
222,111 < 222 , 111
最后：
	m = 222
	n = 111
	
	
var a,_,c = 1 2 3 int 
	blank 黑洞 只能在左边写
	空白标识符
```

![image-20240504174142295](./../images/image-20240504174142295.png)

![image-20240504192051851](./../images/image-20240504192051851.png)



```ABAP
标识符写代码时候，用来指代某个值的。编译后还有变量、常量标识符吗?
没有了，因为数据在内存中，内存访问靠什么?地址，标识符编译后就没有了就换成了地址了

源代码本质是文本文件
编译，源代码编程成二进制可执行文件
运行这个磁盘上的二进制可执行文件，运行在当前0s上，变成进程，进程要不要占内存空问?要的吗?变量、常量、值在这块内存中放着
```



**包内包外**

```go
// 同一个目录下只能有一个包
main  函数叫做入口函数

// 包内可见 不同文件用同一个包 我在B文件顶一个 var b = "abc" （全局变量，包内可见） 我在A文件调用这个包虽然没有定义也可以使用B定义变量；
var ABC = 100  // 全局包外可见/包内也可以

使用 imoprt 导入的包 如果是包外可见 就可以用 如果是小写就不能用
使用package 使用同一个包 即使不在同一个文件中定义过也可以跨文件调用。同一个包内不同的go文件可以互相访问变量，但是就近原则

全局不能用短格式
```

![image-20240505180011483](./../images/image-20240505180011483.png)

![image-20240505191038056](./../images/image-20240505191038056.png)





# 4 类型

## 4.1 布尔型

```go
// bool在go中不是int类型，也不是其他整数类型。在go中，boo1就是布尔型，和整型没有关系，就是完全不同的类型。
true false 字面常量 = bool
```



## 4.2 数值型

复数：complex64 complex128

### 4.2.1 整型

- 长度不同:int8、int16(C语言short)、int32、int64(C语言long)  可以描述负数因为可以带符号
  - 最高位是符号位
  - rune类型本质上就是int32

- 长度不同无符号:uint8、unit16、uint32、uint64 不可以描述负数 因为是无符号

  u即unsigned，最高位不是符号位

  - ​	byte类型，它是uint8的别名

- 自动匹配平台:int、uint  

  int类型它至少占用32位，但一定注等同于int32，不是int32的别名。要看CPU，32位就是4字节，64位就是8字节。但是，也不是说int是8字节64位，就等同于int64，它们依然是**不同类型**

虽然他们都是整型这一类，但他根本上完全不同的类型，go语言对类型极其敏感，不能互操作。



**扩展知识**

```
计算机世界这有二进制数据，每一个位bit表示0或者1，最多表达2种可能性
unsigned = 无符号 以int8 和 uint8 举例：
8bits，总共能够表达256种状态
	int8 -- 1byte -- 8bits 标识正负数将最高位留出来不表示数据状态，用0表示正数 用1表示负数，剩余7bit标识数字
		7bits，总共能够表达256种状态 -128-128
		表示 十进制2
		0 0000010
		表示 十进制-2
		1 0000010
		但计算机中实际上是补码（符合位不动，其余位按照位取反，最后加1）
		1 1111101 取反
		1 1111101  +1
		1 1111110
补码：把减法当作加法，在计算机中所有减法都变成加法，5 - 4 = 1 怎么来的 5 + （-4）= 1 
uint8 -- 1byte -- 8bits 不能标识负数，所有位都用来标识数字
	8bits，总共能够表达256种状态只能标识正数
	十进制2
	00000010
```

 



### 4.2.2 类型

示例：

```go
func main(){
	var m int64 = 50
	fmt.printf("%T %d\n",m,m)
	fmt.printf("%+v\n",string(m))
    fmt.printf("%s\n",string(m))
    fmt.printf("%T %d\n",rune(m))  //rune tyep = int32 
    fmt.printf("%T %d\n",rune(m),rune(m)) // 占位符，每位在右边写，很繁琐
    fmt.printf("%T %[1]d\n",rune(m)) // 整个函数括号中的值是一个数组，有索引（下标）元素已逗号分割，也就是一个逗号一个值对应一个索引。
    
    fmt.printf("%[1]T %[3]d %[2]d %d\n",100，200，300，400) // 最后一个%d的值是什么
    // 最后一个%d值300，前面占位符指定是某个索引，它的值就是索引对应的元素。
    // 如果下一个占位符没有给定索引，那么它的值将根据上一个 %[index]d + 1,来推导出当前占位符的值   
}
// 通过强制类型转换，打印出来，并不是字符"50"，而是“2”。
// go语言会把string中的数值，看作为ascii或unicode码，所有go语言回去查编码表。
```

实例：

![1716876987043](./../images/1716876987043.png)



**格式输出**

```go
fmt.Println Print line 输出到控制台并换行
fmt.Printf("%T %T %T %T \n",a,b,c,a + b + c)  // format
Printf 在控制台打印 f是format
%T 占位符 和后面的值依次对应
T 表示type，取值的类型

%d digital 数值型，往往用于整数形
%s 用打印string类型的值
%q 带引号的字符串%s
%c character 字符输出
%f float 浮点数输出，默认精度.000000
%.2f 表示小数点后两位
%3f 表示宽度 即打印宽度 右对齐

fmt.Printf("%[2]T %[1]d\n", rune(m), string(m)) 值从1开始编
%[indes]，从1开始编号，下一个如果没有指定索引，索引默认是index+1 注意：溢出

type rune = init32  类型别名rune  他是4tytes或32bits int
type myint int32  // 这不是别名 这里没有 =  这里的意思是 我基于int32 新定义了一个新的类型 myint  在go中只要是不同的类型就是不同的
type 可以定类型

type B = int32 // 类型别名，B和int32就是同一种类型的不同名字B、rune(go内建的)、int32是一个类型的不同名称罢了
	var a B = 10 
	var a rune = 10 
```

![image-20240505202830662](./../images/image-20240505202830662.png)

```go
package main

import "fmt"

func main() {
	var k = 100
	w := 100
	var r int = 100
	fmt.Printf("%T %T %T %T\n", k, w, r, k+w+r)
	var m int64 = 999
	fmt.Printf("%T %d \n",m,m)
	// fmt.Printf(k+w+r+m) // 不可以加 因为go语言是强类型  int 和 int64 根本不是同类型
	fmt.Println(k+w+r+int(m)) // 强制类型转换，可能会失败
}
```

**强制类型转换:**把一个值从一个个类型强制转换到另一种类型，有可能转换失败。

 **与其他语言不同，即使同是整型这个大类中，在Go中，也不能跨类型计算、如有必要，请强制类型转换**



![image-20240505215759253](./../images/image-20240505215759253.png)

示例：

```go
package main
import "fmt"

func main() {
	var k = 100
	w := 100
	var r int = 100
	fmt.Printf("%T %T %T %T\n", k, w, r, k+w+r)
	var m int64 = 999
	fmt.Printf("%T %d \n", m, m)
	// fmt.Printf(k+w+r+m) // 不可以加 因为go语言是强类型  int 和 int64 根本不是同类型
	fmt.Println(k + w + r + int(m))         // 强制类型转换，
	fmt.Printf("%+v\n", string(m))          // 数值可以转成字符串 ϧ ，（ascli或unicode码）
	fmt.Printf("%T %d\n", rune(m), rune(m)) // rune = int32  4bits 32bytes
	fmt.Printf("%[1]T %[1]d\n", rune(m))    // 格式化左边可以写右边的索引，默认右边第一个数值索引是1
	fmt.Printf("%[2]T %[1]d\n", rune(m), string(m))
	fmt.Printf("%d,%d;%d.%d]\n", 100, 200, 300, 400)          // 100,200;300.400]  左边只替换%d占位符
	fmt.Printf("%[1]d %[3]d %[2]d %d \n", 100, 200, 300, 400) // 错误 100 300 200 400 正确 100 300 200 300 如果当前没有给定索引，就按照上一个索引的值+1算出当前的索引
	fmt.Printf("%[1]d %d %[2]d %d \n", 100, 200, 300, 400)    // 100 200 200 300
}
```



##### **类型别名**

```go
package main
import "fmt"

func main() {
//	var a = 100
//	var b int64 = 200
//	var c rune = 300 // type rune = init32  类型别名rune  他是4tytes或32bits int

	//这两个的意思完全不同
	type B = int32    B 指代 int32   B可以和int32类的值互操作      类型别名
	type x int32	  我创建了一个型类型X 他的类型是int32新的类型	重新定义 虽然你的本质也是int32 但是你是新的类型
	
	type x int32
	type B = int32 
	var G B = 100
	var m x = 111
//	fmt.Println(G + m)    因为G的类型是B B是int32 m的类型是x x类是也是int32 但是x是新定义的类型 不能直接计算
fmt.Println(G + int32(m)) 强制类型转换
}

```

##### **二刷**

```go
// 类型别名，rune的类型 = int32，别名就是rune代表int32。不是型类型，可以互相操作。
type rune = int32
// 定义新类型zedint，它的类型是int32，不是别名。
type zedint int32 

虽然本质int32，但 rune 和 zedint 不是相同的类型，zedint是基于int32定义的新类型

type A int32
type B = int32

var c B = 100
var d rune = 200
fmt.println( c + d ) // 可以相加，因为B是int32的别名，rune也是int32的别名。类型一样可以相加。
var m A = 1000
fmt.println( c + m ) // 不能相加，因为c的类型是B，B是int32的别名，而m是A类型，A != int32
fmt.println( c + int32(m) ) // 类型转换
```



### 4.2.3 字符和整数

```go
package main
import "fmt"

func main() {a
	var a = '测'
	fmt.Printf("%T %[1]d\n",a)   
}
打印：int32 27979（10进值）

fmt.Printf("%T %[1]d %[1]c\n",a)
// '测' 单引号在GO中默认是rune类型 rune类型是 int32 的别名
// '测' 是字面表达，实际上最终存在计算机中是数字，这是一种方便我们书写代码的格式化，实际上程序会自动转换成数字。
// %d解释为整数，%c解释为字符。内存中一个数据，看你赋子它什么类型，就可以看到不同的东西。

rune 类型保存的是字符，字符的unicode码。
重新赋值，不是重新定义，不会改变类型
```

示例：

```go
var a = '测'
	a = 'abc' // 错误，字符只能是单个，多个就要定义为“abc”
	a = 'c'   // 正确，重新赋值，a的类型是什么type rune = int32，重新赋值类型不变。不是重新定义
fmt.printf("%T %[1]d %[1]c\n",c)
			int32  99   c
	a = 99 	  //  这里不同于定义变量时，不会使用类型推导，而是给a重新赋值为99。千万不能理解成99是int缺省类型。在定义变量时，没指定才会用缺省。这里a 已经时rune类型，而rune就是int32，int32可以定义99整数呀。			*****涉及到隐式类型转换，请看下一小节*****
fmt.printf("%T %[1]d %[1]c\n",c)

	a = '0x63' // 不对，这是代表整数
    a = '\x63' // 正确，告诉Go语言'\x63'代表的是一个字符。虽然是一串数字，但是他代表一个字符

// 计算机本质都是数值，重点是如何解释，如果解释为数值那么就是数值。如果解释为字符，那么就去查ascii码表。
实例:
    func main(){
        var b = '测'
    fmt.printf("%T %[1]d %[1]c\n",b)
    int32 27979 测 
        b = 27979 // 隐式类型转换 b = int32(27979)
    fmt.printf("%T %[1]d %[1]c\n",b)
    int32 27979 测 
    }
```

##### 结论

```abap
可以认为Go语言中没有字符类型，本质上是int32的别名。习惯性称rune为字符型。所谓的字符型，也就是rune类型，说白了字符型就是整数。
```

##### 隐式类型转换

```GO
// 这两条赋值语句意义相同，语法糖（隐式类型转换），提高开发效率。
var a int32 = 100 // 隐式类型转换
var a int32 = int32(100) // 如果等于号右边是untyped constant，会根据等于号左边的类型对等于号右边的类型，进行隐式类型转换。
	a = 99 // 什么意思？= 隐式类型转换
// 在上面已经确定变量标识符a的类型为int32，右边的99是字面常量缺省类型int。
// a = 99 重新赋值，而不是重新定义所以类型不变。
   a = int32(99)  等价于  a = 99

// 隐式类型转换只作用于 untyped constant
var z int32 = 10086
var x int64 = z // 报错，不可以因为z是int32，x是int64。需要手动进行类型转换
var x int64 = int64(z)
         n := z // 可以n没有指定类型，可以利用Z做类型推到。
```

##### 自动类型提升

```go
var m int32 = 100
		 n := 2.2
fmt.printf(n+m)		 	 // 不能相加，因为m类型是int32,n类型是float64。
fmt.printf(n+float64(m)) // 强制类型转换可以相加

fmt.printf(100+2.2)  // 可以相加，untyped constant的特权，有隐式类型转换
fmt.printf(float64(100) + 2.2) 

var x int = int('测')
var x int = '测' // 测 = int32 = 4byte = 27979 = unicode码 
var x  = ”测“    // string utf-8
```



### 4.2.4 浮点数

示例：

```go
	var m int32 = 100 // 左边类型int32 右边int 会做隐式类型转换等价于 m int32 = int32(100)
	var n = 2.6       // float64
	// fmt.Println(m+n) m 和 n 不能直接加因为类型不同
	fmt.Println(float64(m) + n)    // 强制类型转换
	fmt.Println(100 + 2.65)        // 可以加 因为untyped constant类型隐式类型转换 100是int 2.6是float 会把100提升为float64
	fmt.Printf("%f\n", 100+2.65)   // 默认 .000000
	fmt.Printf("%.2f\n", 100+2.65) // %.2f 小数点后两位
	fmt.Printf("%30f\n", 100+2.65) // %30f 宽度右对齐，30包括打印打字符多余的用空格补充，打印的数值会把宽度覆盖，如果宽度覆盖了打印的值，多余的用空格补。如果没覆盖则看不出。
	fmt.Printf("%-30f\n", 100+2.65)// %-30f宽度左对齐
	fmt.Printf("%30.1f\n", 100+2.65)// %-30.1f宽度左对齐并且只显示小数点后1位
```

图示：

![image-20240528173451815](./../images/image-20240528173451815.png)

示例：

```
var c rune = '中' // 字符用单引号。想一下，计算机中有中文吗？
fmt.printf("%T %c %d\n",c,c,c)
int32 测 27979

var c byte = '中' // 报错， '中 '= rune = int32 > 1 byte 
var m byte = 'a'  // 正确， a是ascii表，不超过 1 byte

var e rune = 27979
fmt.printf("%T %c %d\n",e,e,e)
int32 测 27979
```

```ABAP
字符串是由若干个字符组成，在内存中使用utf-8编码。而rune只能保存一个字符，输出是unicode。
```



### 4.2.5 进制转换

常见进制有二进制、八进制、十进制、十六进制。重点掌握二进制、十六进制。

十进制逢十进一;十六进制逢十六进一;二进制逢二进一

**什么是权**

```
"权" 指的是每个数位上的数值所代表的实际大小.由于在不同的数位上，相同的数字代表的实际值是不同的。
“权”的概念是为了帮助我们理解在不同进制数系统中，每个数位上的数字是如何转化为实际数值的。
```

**按位权算**

权的值 = 当前基数位置的幂次方 （第几位就几次方）

即每一位的数值乘以它所处位数的基数幂次。

**按位乘权求和**

```bash
当我用十进制表示数字的值时：每个数字在某个特定位置上的值，由其在该位置上的数值乘以该进制基数的位置次幂
第一位（从右向左）通常代表的是0次方，第二位代表的是1次方。（千3 百2 十1 个0）
#总结(^托字符代表幂运算)
sum(每位的数值 = 位置上的数字 x 权 = (基数的位置次幂))
2^3 2^2	2^1	 2^0
ob1  1   1    0
```

**基数**

- 在二进制系统中，基数是2，因为每一位只能是0或1，即2的0次幂或2的1次幂。
- 在十进制系统中，基数是10，因为每一位可以是0到9，即10的0次幂到10的1次幂
- 每一位上可能出现的不同数字的最大数量。
  -  十进制的基数是10，因为每个位置上的数位可以是0到9。
  - 二进制的基数是2，因为每个位置上的数位可以是0或1。
  - 八进制的基数是8，因为每个位置上的数位可以是0到7。
  - 十六进制的基数是16，因为每个位置上的数位可以是0到15。


**进制**

- “二进制”是一个进制数制，它使用基数2，只有两个数字符号：0和1。
- “十进制”是一个进制数制，它使用基数10，有十个数字符号：0到9。

```
十进制 1234  =  1 * 10^3 + 2 * 10^2 + 3 * 10^1 + 4 * 10^0 = 1000 + 200 + 30 + 4 = 1234
二进制 0011  =  0 * 2^3  + 0 * 2^2 + 1 * 2^1  + 1 * 2^0 =  0 + 0 + 2 + 1 = 3 
八进制 3145  =  3 * 8^3  + 1 * 8^2 + 4 * 8^1  + 5 * 8^0 = 1536 + 64 + 32 + 5 = 1637
```

练习：

```bash
#二进制和十六进制之间的转换基于它们基数之间的关系：十六进制是基于16的数制，而二进制是基于2的数制。由于16是2的4次幂，所以每4位二进制数可以表示一个十六进制数位。
二进制    十六进制
0000        0
0001        1
0010        2
0011        3
0100        4
0101        5
0110        6
0111        7
1000        8
1001        9
1010        A
1011        B
1100        C
1101        D
1110        E
1111        F
```

**总结**

```ABAP
四位二进制数可以转换为一个十六进制数，是因为二进制的四位可以表示的取值范围是 0-15，十六进制单个数字的取值范围也是0-15（0-f），所以四位二进制可以映射成单个十六进制数。
三位二进制数映射成单个八进制数（同理）
```

练习：

```bash
#二进制和八进制转换基于他们之间的基数关系：8进制的基数是8，而二进制的基数是2.由于8是2的3次幂，所以每3位二进制可以表示一个8进制数。
二进制    八进制
 000		0
 001		1
 010		2
 011		3
 100		4
 101		5
 110		6
 111		7

0b11 110 = 0o 36 = 30  
0b1 1110 = 0x 1E = 30  

0b11 10 0 011 = 0o 343 = 227 
0b1110   0011 = 0x E3  = 227 
0o 343 = 0b 11100011
0x E4 = 0b 1110 0100
```

练习：

```c
无符号数为例，8位，256
    00000000
    11111111 = 0xff
BCD
8421
ob1111 = 1 + 2 + 4 + 8 = 15 = F
ob1110 = 0 + 2 + 4 + 8 = 14 = E
ob1100 = 0 + 0 + 4 + 8 = 12 = C
ob1000 = 0 + 0 + 0 + 8 = 8  = 8 

二进制到16进制 每4位一段
0b 1001 =  9 = 0x9
0b 1010 = 10 = 0xa
0b 1011 = 11 = 0xb
0b 1100 = 12 = 0xc
0b 1101 = 13 = 0xd
0b 1110 = 14 = 0xe
0b 1111 = 14 = 0xf

二进制到8进制 每3位一段

0b 0 000
```



```
十六进制转为二进制
0xF8 按位展开即可，得到 0b1111 1000

八进制转二进制
0o644 按位展开即可，得到 0b110 100 100
```

![image-20240528220449503](./../images/image-20240528220449503.png)



![image-20240528220852983](./../images/image-20240528220852983.png)



**十进制转二进制**







![image-20240512165847056](./../images/image-20240512165847056.png)



**有符号无符号数**

```go
// 无符号数，8位256状态，[0 - 255]
00000000 = 0
11111111 = 255
// 有符号数比无符号数少一位,少的第一位0代表正数或1代表负数，虽然比无符号数少一位，但还是256状态
0_0000000 - 0_1111111 = 0_0x7F [0 - 127] 	128个数字，128状态
1_0000000 - 1_1111111（-127） = 1_0x7F [-1 - -128]	
			1_00000000（-128）		      128个数字，128状态  -1 - 128
```



## 4.3 转义字符

每一个都是一个字符，rune类型（int32）。可以作为单独字符使用，可以作为字符串中的一个字符

```
\a	bell
\b	backspace
\f	feed
\n	new line
\r	return
\t	tab
\v
\\  \号是转换别人的符号  \\表示把\转意成 \原本的意思
\'  单引号是用来界定字符类型的   让'代表本身的意思\' 而不是界定字符,代表单引号
\"  双引号是用来界定字符串类型的 让"代表原来的意思\" 而不是界定字符穿，代表双引号
```

问题：在Go中‘\n’和"\n"有什么区别？

```
类型不同，'是字符'，“是字符串”
'\n' 是字符，字符 = rune  =  int32 = 整数
```



## 4.4 字符串

Go语言中不能使用单引号定义字符串

单引号用来表示字符，字面量表达，本质上是int 32 (rune)或 byte( uint8)

双引号和反引号用来表示字符串字面量 ""|``

```go
package main
import "fmt"

func main(){
    var s = "abc"
    	s = "z\tx\nc"
    	a = `x\nz\t`   // ``中的转义字符失效，但键盘中的功能键可以生效
    fmt.println(s)
    fmt.println("~~~~~~~~~~")
    fmt.println(a)
}
// 打印结果
z	y
c
~~~~~~~~~~
x\nz\t
```

![image-20240529120545092](./../images/image-20240529120545092.png)

打印结果：

![image-20240529120719027](./../images/image-20240529120719027.png)



##### TAB键

```go
一个tab键是八个字符
前面有多少字符，并不会影响tab键的起始点。

 tab键
12345678
x       y     // 源码x\ty，三个字符，而显示9个字符。
xvf     y
xxxxxxxx        y
字符或字符串，所占用的字节数（占用多少字节，内存和磁盘使用量），在不同的显示设备中展示的宽度
// 单引号用来多行输出，或者代码中有双引号不用频繁转义。

var a = "x\ty\n\"'z'\""  // 一共9个字符，拆开数。
x
\t
y
\n
\"
'
z
'
\"
var a = "'" // 双引号中的单引号为什么不需要转义
a 的类型是字符串，字符串中有一个字符 ‘ 单引号。所以不需要转义，没有歧义
```

![1716956109804](./../images/1716956109804.jpg)

####  字符串格式化

```go
%v	适合所有类型数据，调用数据的缺省打印格式
	%+v	详细打印
	%#v 更详细打印
%T 	打印值的类型
%%	打印百分号本身

整数
%b 二进制； %o 八进制；%O 代表有前缀；%x 十六进制小写；%X16 进制大写
%U 
%c 利用数字查表  把rune类型映射成 unticoer
%q 想看中文字符 类似%c

浮点数
%e %E 科学计数
%f %F小数表示法
%g 内部自动选择%e还是%f；%G 自动选择%E、%F

字符串/切片
%s
%q  qoute引号


指针
%p 十六进制地址
```

![image-20240529150727101](./../images/image-20240529150727101.png)

#### 输出函数

输出到标准输出 stdout

- Print : 使用缺省格式输出，空格分割
- Println：使用缺省格式输出，空格分割，最后追加换行
- Printf：按照指定的格式符输出

不输出到控制台，而是输出到字符串，用来拼接字符串

- Sprint ：相当于print，不过输出为string
- Sprintln：相当于println，不过输出为string
- Sprintf：相当于printf，不过输出为string

```go
package main

import "fmt"

func main() {
	var s = 27979 // 6 x 16^3 + 13x16^2 + 4x16^1 + 11 =
	fmt.Printf("%+v %[1]d %[1]b %[1]o  %[1]x %[1]X %[1]c %[1]U\n", s) // %c查表 unicode
	t := fmt.Sprintf("%+v %[1]d %[1]b %[1]o  %#[1]x %[1]X %[1]c %[1]U\n", s)
	// Sprint 要给他一个变量，把输出的字符串保存到变量t中。
    // fmt.print(s) 调用缺省格式输出
	// fmt.Println(t) 调用缺省格式输出 + \n
	// 生产字符串，然后输出到标准输出
    // 用后面写的变量，填充前面的字符串占位符，最后输出到标准输出
}

6d4b 等于多少字节
转成二进制    0110 1101    0100 1011  1位16进制数表示4位二进制，8位1字节，2两个字节
```



# 5 操作符

```go
// 随笔
定义变量
var a,b int = 100 200
a,b := 10,"abcd" 
```



在Go语言中，1就是整数，true就是bool。这点和其他语言不同，1可以代表true。

下图是其他语言中的示例：这里我们用1代表true，0False

## 5.1 逻辑运算表

![image-20240529153911121](./../images/image-20240529153911121.png)

```
非逻辑：
	真取反假
	假取反真
与逻辑（乘法）：
	0 x 0 = 0
	0 x 1 = 0
	1 x 0 = 0
	1 x 1 = 1
或逻辑（加法）：
	0+0=0
	0+1=1
	1+0=1
	1+1=1 (虽然是加法，但是或运算没有进制的概念，不会进位变成2)
```



## 5.2 算数运算符

```
+、-、*、/、%、++、--
5 / 2 整数 / 整数 = 整数 会四舍五入
（-5 ）/ 2  
取摸运算就是求余数 5 % 2 = 1 

+ - x / ,因为他么都需要两个操作数 = 双目运算符
-5，负号只需要一个操作数 = 单目运算符（优先级高）
在Go语言中后缀递增(i++,i--)不可以写在函数中(i++是语句)。

Go中没有++i，--i
前缀递增递减和后缀递增递减的区别：
i++,i--和++i，--i的区别，前者先返回数值比较条件，然后++。后者先++，然后返回值后在比较条件。 
延迟递增
即时递增
```



## 5.3 常量计算问题

常量分为typed类型和untyped constant

常见错误

```go
var a int = 1
var b float32 = 2.3
fmt.Println(a*b) // 报错，因为int和float32类型不同，除非强制类型转换，GO语言这种情况不会进行隐式类型转换

var a = 1
var b = 1.1
fmt.Println(a*b) // 错误，类型不同，强制类型转换，变量都有类型，不会做隐式转换。

fmt,Println(1*1.1) // 可以，无类型常量，会做隐式类型转换

var a = 1 * 2
fmt.Printf("%T %[1]v %[1]d\n",a)
因为右边使用的都是字面常量，而字面常量都是无类型常量untyped constant，它会在上下文中隐式转换。Go为了方便，不能过于死板，增加程序员转换类型的负担，在无类型常量上做了一些贴心操作。
```

**上面的常量被赋给了变量，这些变量就确定了类型，虽然他们指向的值是字面常量，但是计算使用变量，但变量的类型不一致，报错。**



## 5.4 位运算符

**&位于（逻辑与）**

```
与运算就好比是个筛子15 & 9  按位透传
1111
1001
1001
只要9有的数就可以透传我们想要的数字，9是0就把我梦原来的数字过滤掉了
??? & 1
01010101010100101/0
00000000000000001
00000000000000001/0
未知数最后一位如果是1那么结果就是1，未知数最后以为如果是0，结果就是0。前面的位全被过滤掉了，只有最后1位没有每过滤。

？？？& 15 什么意思，只取后四位
1010101010100100011
0000000000000001111



&^  取反与运算，按位清除 0是1  1是0
1001
1101
0100


15 & 5 = 5
1111
0101
0101
15 &^ 5 = 10
1111
0101
1010
```

![image-20240529170453207](./../images/image-20240529170453207.png)

**|位或（逻辑或）**

![image-20240529170808572](./../images/image-20240529170808572.png)

**^异或（不同为真）**

![image-20240529171105107](./../images/image-20240529171105107.png)

```
移位 << >> (相当于乘法，每移动1位，就是1次方)
1 << 1
移动前：0000 0001
移动后：0000 0010
1 << 2
移动前：0000 0001
移动后：0000 0100
3 << 1
移动前：0000 0011
移动后：0000 0110
```





## 5.5 比较运算符

```go
< > == !=  >=  <= 双目运算符号，比较表达式，需要两个操作数。对于Go语言来说不管什么一定要有类型，比较的结果一定是bool型。 两个操作数只要是整型就可以比较。
结果：true|false
5 > 3
5 > 'a'  // 可以本质都是整数
5 > "a"  // 不可以，类型差距太大
5 == "a" // Go不可以，其他语言可以，跨类型比较是不是同类型。但从语义上分析，跨类型比较根本无法计算


逻辑与运算：&& 
逻辑或运算：||
逻辑取反： ! 
逻辑运算符，只能操作逻辑值bool型，true和false。返回的结果是什么？也是bool型。
在Go中不可以用逻辑运算符操作非bool.在其他语言中，可以做某些类型等效看作bool
1 = true, 0 = false,空串看作false,非空串看作true。
1 && 5 > 1  // 报错

短路
true || false || false || false // 第一个为真，那么后续是真，1 任何数或都是1，有一个1，就算真
false|| false || true   // 判断第一个加，判断第二个家，判断第三个真，
false && true && true // 最后还是0，因为0x任何数=0
 0         1

true && false || false
先比较，后逻辑
5 > 3 && 4 > 2 
```



## 5.6 赋值运算符

![image-20240529195505115](./../images/image-20240529195505115.png)

示例：

```
a += 8
a = a + 5 
a += 10 + 5 
a = a + 10 + 5 
a *= 10 + 5 
a  = a* (10 + 5) 
```



## 5.7 三元运算符

Go中没有三元运算符

没有 ?:的原因是，语言的设计者看到这个操作经常被用来创建难以理解的复杂表达式。在替代方案上，if-else 形式虽然较长，但无疑是更清晰的。一门语言只需要一个条件控制流结构。



## 5.8 指针操作

```
变量标识符的本质，指向指代某个值，编译后会被解释成内存地址。
指针是一种类型某种类型的值，本质上是一个大整数，简单说这个整数就是内存中的门牌号，房间中住着一个客人就是我们的数值。
*int是指向int类型数据的指针的一种类型
0xc000018088 内存地址，门牌号，利用这个门牌号，可以找到房间中的100数值。
*变量指针 表示通过指针取值
&变量 表示通过变量取地址
```

示例：

```go
func main(){
	a := 100 // 编译后，100数值存在内存中的某个地址，而a变量标识符指向这个地址。但a不是指针类型它是缺省int。a的类型是由它指向的值决定，
    b := &a // 取地址操作符
    fmt.Printf("%T %[1]v\n",b)
    c := *b // 通过地址取内容，c的类型是int
    fmt.Printf("%T %[1]v\n",c)
    
    fmt.Println( a == c )
    fmt.Println( b == &c ) // 地址不相等，*b提取内容，然后在内存中开辟新的门牌号放入房间（副本），赋值给c
    b指代a（100）的门牌号也就是内存地址，但b在内存中也有自己的门牌号。
    
    var d = a 
    fmt.Println(d == a)     true
    fmt.Println(&d == &a)   false // 赋值在Go中，往往是建立副本，重新赋值
    目前来看，只要定义赋值就会开辟新的内存空间，创建副本赋值给标识符
}
显示：*int 0xc000018088
显示：int 101
```

![image-20240529202145544](./../images/image-20240529202145544.png)



![image-20240529203212508](./../images/image-20240529203212508.png)

## 5.9  优先级

![image-20240529211155853](./../images/image-20240529211155853.png)

![image-20240529211438612](./../images/image-20240529211438612.png)

```
单目 > 双目
算数 > 位移 > 比较 > 逻辑 > 赋值  
记不清直接上括号
```





# 6 程序控制

- 顺序
  - 按照先后顺序逐条执行
  - 例如：先到厕所，脱裤子，蹲下，拉屎

- 分支
  - 根据不同的情况判断，条件满足执行某些条件下的语句
  - 例如：洗手，吃饭，饭没熟，躺会，如果饭熟了吃饭。没饭就点外卖
- 循环
  - 满足条件就是循环执行，不满足条件就不执行
  - 例如：先洗手，先看看饭菜好了没，没好就过一会儿再看看，再看看，没好，再看看，直到饭菜好了，直接吃饭，退出查看饭好没好的循环。



## 6.1 单分支

```go
// Go语音对类型比较敏感，条件只能bool，或者是可以返回bool值的表达式
// 条件成立进入，并执行代码块，为了防止风格问题，左花括号只能写在if同一行
if condition {
	代码块
}

if 5 > 2 {
	fmt.Print(a)
}
```

注意：Go语言中，花括号一定要跟着if、for、func等行的最后，否则语法出错。这其实就是为了解决C
风格、Java风格之争。

- condition必须是一个bool类型，在Go中，不能使用其他类型等效为布尔值。if 1 {} 是错误的
- 语句块中可以写其他代码
- 如果condition为true，才能执行其后代码块



## 6.2 多分支

```go
// 如果满足条件1 执行条件1，就不能进入其他if语句，如果以上都不成立，执行最后一个else。
if condition {
	代码块1
} else if condition {
	代码块2
} else if condition {
    代码块3
} else if condition {
	代码块4
} else {
	代码块 // 最后一个else很重要，容易出现逻辑漏洞，以上情况都不满足，那么都不满足咋办，执行什么操作。这里就必须要考虑是不是要加一个else来兜底。
}
```



```go
func main(){
	a := 5
	if a < 0 {
		fmt.Print("negative")
	} else if a == 0 { // 走到这一层，表示a不小于0，也就是a可能大于0
		fmt.Print("zero")
	} else {	// a 大于 0 
		fmt.Print("big")
	}
}

嵌套写法 两层嵌套和三层嵌套，多了太恶心
if a < 0 {
    fmt.Print("negative")
} else {
    if a == 0 {
        fmt.Print("zero")
    } else {
        fmt.Print("big")
    }
}
```



## 6.3 switch分支

```go
func main(){
	a := 5
	switch a {
	case 1:
		fmt.Print("1")
	case 2:
		fmt.Print("2")
    case 5:
        fmt.Print("5")
	default:
		fmt.Print("a 不是1 and 2")
	}
}

////
func main(){
	a := 5
	switch  { // switch后面写什么类型，case就是什么类型。 如果switch后面不写，默认bool
	case a > 1: // 报错：a > 1 返回的值true false，返回的值不能转换为int ? 为什么要转换为int呢？谁是int？
		fmt.Print(a)
    case a == 0:
        fmt.Print(a)
    case a > 0 || a == 0:
        fmt.Print(a)
    default:
        fmt.Print(-shu)
	}
}

////
func main(){
	switch a := 5;a { // 这个a只能再当前switch中用 封号代表作用域，其实相当于switch后面啥也没写
	case 1:
		fmt.Print("1")
        fallthrough // 下落穿透，满足第一个case直接语句块跳过其他case，直接执行其他的case语句块，C语音语音中默认自动下落，需要加break阻止。而再Go中默认关掉，想使用就要fallthrough而且哪层加就再那层传头，要先都穿，都得加。
	case 2:
		fmt.Print("2")
        fallthrough
    case 5:
        fmt.Print("5")
	default:
		fmt.Print("a 不是1 and 2")
     fmt.Print(a) // 无法打印a
	}
}
```

恶习（尽量别用）：C语言的switch有穿透效果，而Go语言没有。如果想在Go语言中实现穿透效果，使用fallthrough穿透当前case语句块。但是，大家使用C语言的时候，一般都不想要使用这种穿透效果，所以，如非必要，不要使用fallthrough。



## 6.4 特殊if

switch可以写成 switch a:=20;a这种形式，也就是可以在表达式a之前写一个语句后接一个分号。if也
可以这样

```go
if score,line := 50,90; score > line {
		fmt.Print(good)
} else {
	fmt.Print(sb)
} // score,line 只能作用与当前if语句
```



## 6.5 for循环

注意：Go语音中没有提供while关键字，只有一种循环，简洁。

**C风格for**

```go
for i := 0; i < 6; i++ {
    fmt.Print(i)
}
1. i := 0 init初始化，在循环开始之前，只执行一次
2. i < 5  bool,中间部分只能是bool值，这个bool值是true才能执行后续花括号中的语句一次。
		  如果要执行第二次，需要test检验这个表达式的值是否是true，如果是继续，如果是false，abort
3. i++    循环体如果执行过一次的结尾时执行。

先初始化，判断i是否小于6，如果i小于6，进入循环体执行代码块。循环体执行完 i++
最后+到6，在做一次test返回false，循环终止，最后i = 6。

	i := 0; 
for i < 6; i++ {
    fmt.Print(i)
}
fmt.Print(i) // 把i在外面定义，生效范围变大，最后i=6退出循环
显示：6

for 不写就是true i++ {
    fmt.Print(i)
}
// 特殊写法
for i := 1; i < 5; {} // 需要在循环体内部解决死循环的问题，因为如果i的值不变一直小于5，一直执行。
for i := 1;; {}  // 没有条件，默认为true，必须在循环体语句块中解决死循环问题。
for i < 10 {}	 // for condition {} condition循环条件
// 下面这两句一样
for {} 			 // 死循环
for ;; {}        // 死循环 相当于for true {}
```



### 6.5.1 continue和break

```go
for i := 0; i < 10; i++ {
    if i%2 == 0 {
        continue // 结束当前循环的这一次，然后执行i++，去test，判断能否执行下次循环
        	     // 循环可以嵌套，结束当前循环就是找离continue最近的for，按代码缩进找
    }
    fmt.Print(i)
}


for i := 0;;i++ { // 没写结束条件，死循环。
    if i == 10 {
        break
    }
    if i%2 == 0 {
        continue 
    }
    if i > 10 {  // 放在这里必须大于等10
        break    // 终止当前循环 
       
    }
	fmt.Print(i)
}

MYFOR:
    for i:= 0; ; i+=2 { // 改成1基数，改正0偶数  i+=2调整步长
        if i >= 10 { 
            break MYFOR // 退出MYFOR循环。用于嵌套循环时，退出终止多层循环，可也用goto替代
          //  goto END	无条件跳转
        }
        fmt.Print(i)
    }
END:
fmt.Print(退出)
0
2 
4
6
8 

```



### 6.5.2 goto和label

这是一个被很多语言尘封或者废弃的关键字，它会破坏结构化编程，但是确实能做到便利的无条件跳
转。

- 跳出多重循环使用，但是问题是为什么要用多重循环?
- 到同一处标签处统一处理，例如统一错误处理。问题是，写个函数也可以实现。

有时候也能简化一些代码，但是它是双刃剑，**不要轻易使用**。

goto需要配合标签label使用，label就像代码中的锚点，goto将无条件跳到那里开始向后执行代码。

```go
for i := 0; ; i++ { 
	if i%2 == 0 { // i & 1 == 0 转成2进制与
		continue
	}
	fmt.Print(i)
	if i > 10 {
		goto out
	}
}
tou:
fmt.Print(退出)
```



### 6.5.3 for range

遍历容器中的内容，比如一个字符串是由多个字符组成。容器内所有元素遍历。

```go
// 遍历：按照某种顺序输出（线性），不重复的把所有元素输出出来。不关心容器内部元素是否有序。
	a := "asd123"
 	for i,v := range a {
    fmt.Println(i,v)
}
// 字符串中是由单个字符组成，单个字符是rune，也就是int32对应unicode表数字
0 21
1 45  
2 78
3 65
4 123
5 15
6 47

// 在Go语言中，i 字节索引，ascii表 英文占1个字节。字符串中文utf-8，占三个字节
// for range会自动把字符串转换成utf-8 > unicode
asd  测  试     utf-8 3byte
012 345 678
	b := "asd测试"
 	for i,v := range b {
    fmt.Println(i,v)
    fmt.Printf("%T %[1]v\n",v) // rune 是unicode码
}
0 21
1 45  
2 78
3 27979
6 35797
```



### 6.5.4 嵌套循环

```go
package main

import "fmt"

func main() {
	for i := 1; i <= 9; i++ {
		// fmt.Print(i,i,i,i,i,i,i,i,i,i,i,i)
		// fmt.Print(i, 1)
		// fmt.Print(i, 2)
		// fmt.Print(i, 3)
		// fmt.Print(i, 4)
		// fmt.Print(i, 5)
		// fmt.Print(i, 6)
		// fmt.Print(i, 7)
		// fmt.Print(i, 8)
		// fmt.Print(i, 9)
		// fmt.Println()
		for j := 1; j <= i; j++ {
			fmt.Printf("%d%c%d%c%d\t", i, '*', j, '=', i*j)
		}
		fmt.Println()
	}
}
```

![image-20240530223437757](./../images/image-20240530223437757.png)



## 6.6 随机数

标准库"math/rand"
我们使用的是**伪随机数**，是内部写好的公式计算出来的。这个公式运行提供一个种子，有这个种子作为起始值开始计算。

- src:= rand.NewSource(100)，使用种子100创建一个随机数源
- rand.New(rand.NewSource(time.Now().UnixNano())，利用当前时间的纳秒值做种子
- r10:= rand.New(src)，使用源创建随机数生成器
- r10.Intn(5)，返回[0,5)的随机整数

```go
func main(){
    rand.seed(1)  // 1.20 之后修改种子
	fmt.println(rand.intn(10)) // 快捷随机 0 - 9 随机数 1.20版本以后才有

        src := rand.NewSource(10) // 种子的源头，也就是随机数公式的起始点。也就是说公式是死的，只要起始点一样算出的值就一样。
        gen := rand.New(src)	  // 随机数生成器，使用src源。
    	for i := 0; i < 10; i++ {
        fmt.Println(gen.intn(8))
		}
    // 只要种子一直变化，那么计算的源头就一直变化，得出的值就不同 1.20之前这么些。
    src := rand.NewSource(time.now().unixnano()) // 取当前实际，纳秒
    gen := read.New(src)
    for a := 0; a < 10; i++ {
        fmt.Println(gen.intn(5))
    }
}
```





# 7 数据结构

## 7.1 数值处理

### 7.1.1 取整数部分

```go
fmt.Print(1/2,3/2,5/2)
fmt.Print(-1/2,-3/2,-5/2)
fmt.Print("~~~~~~~~~~~~~~~~~~~~~")
fmt.Print(math.Celi(2.01),math.Celi(2.5),math.Celi(2.99)) // 只要大于2就往高位取，比2大，3
fmt.Print(math.Celi(-2.01),math.Celi(-2.5),math.Celi(-2.99)) // -2最大取-2
fmt.Print("~~~~~~~~~~~~~~~~~~~~~")
fmt.Print(math.Floor(2.01),math.Floor(2.5),math.Floor(2.99))   // 取小值
fmt.Print(math.Floor(-2.01),math.Floor(-2.5),math.Floor(-2.99)) 
fmt.Print("~~~~~~~~~~~~~~~~~~~~~")
fmt.Print(math.Round(2.01),math.Round(2.5),math.Round(2.99)) // Go中是 四舍五入
fmt.Print(math.Round(-2.01),math.Round(-2.5),math.Round(-2.99))
fmt.Print(math.Round(2.01),math.Round(2.5),math.Round(2.99))

运行结果(只保留了整数，小数点后面舍弃了。)
0 1 2 
0 -1 -2 
~~~~~~~~~~~~~~~~~~~~~
3 3 3 
-2 -2 -2 
~~~~~~~~~~~~~~~~~~~~~
2 2 2 
-3 -3 -3 
~~~~~~~~~~~~~~~~~~~~~
2 3 3      
```

- / 整数除法，截取整数部分
- math.ceil 向上取整
- math.Floor 向下取整
- math.Round 四舍五入

![image-20240530152559552](./../images/image-20240530152559552.png)



## 7.2 标准输入

Scan:空白字符分割，回车提交，换行符当作空白字符。

可以用逗号作分隔符，但仅限于整型。字符串不行，会把逗号识别为字符串。

```go
func main() {
    var (
        name string
        foot  int 
    )f
	n,err := fmt.Scanf("%s %d",&name,&foot)
    if err != nil{
        panic(err)	// 程序要崩溃，不再执行后续代码。
    }
    
    
    if err == nil {
        fmt.println(n,name,age)   // err 为nil=成功，成功时拿到了几个参数。
    } else {
         fmt.Println(err) 		  // nil空,没有错误
    }
}
   
// 我定义了a和b，我希望他们的值来源于标准输入。但Scan函数需要知道a和b的内存地址，才能操作他的值。
&a 和 &b 分别是变量 a 和 b 的内存地址。当你调用 fmt.Scan(&a, &b) 时，你告诉 fmt.Scan 函数从标准输入读取两个值，并将它们分别存储在由 &a 和 &b 指定的内存位置（即变量 a 和 b 的内存位置）。然后，fmt.Scan 会返回成功读取的项数 n（如果一切正常，应为 2）以及可能发生的任何错误 err。如果 err 为 nil，则表示没有错误发生，并且 a 和 b 已被成功赋值。
```

fmt.scanf("%s,%d"，&name，&age)中%s会和后面的非空白字符分不清楚，用 abc,20 是匹配不上的，因为除空白字符外，都可以看做是字符串。所以，建议格式字符串中，一律使用空格等空白字符分
害。





# 8 线性数据结构

## 8.1 通用概念

**逻辑概念**

- 线性表，有序序列，是一种可以按照特定顺序存放元素的容器。

**物理实现**：在内存中怎么表达该序列。内存是线性编地址。

- 顺序表：使用连续的内存单元存储该序列的所有元素。把内存中一块连续的空间拿出来，按照元素占用字节划分。一个元素占几个字节，把这几个字节作为一个存储单元，按照顺序存储。内存的顺序就是数据的顺序。
  - 数组

- 链接表：每一个元素都在内存中，但元素并不是连续的存储在内存中。散落在内存的不同位置。前一个元素指向下一个元素。

  - 列表，
  - 单向：前一个元素指向下一个元素。

  - 双向：前一个元素指向下一个元素，下一个元素指向上一个元素。

**顺序表图示：**

![image-20240531141659973](./../images/image-20240531141659973.png)

**单向链表图示：**

![image-20240531143034359](./../images/image-20240531143034359.png)



### 8.1.1 顺序表Array

```ceylon
Go每个元素占用的一样，在定义数组是就要明确类型。
对顺序表来数
	要开辟一块连续的内存空间，容器占用的内存称为容量，最多容纳多少个元素。
	当前容器目前的元素个数，称为长度	
    Create：
    	容器元素个数 + 1
    	append，如同排队，在当前长度尾部追加。容量满了，容器不可变将无法增加。 
    	insert，如同插队；
    		末尾插入 = append
    		中间插入:占用要插入的地址，把当前位置与其后所有元素后移。
    		起始插入:所有元素统统后移。
    		数据移动消耗时间，规模越大代价越大。
    Read：
		定位问题：首地址 + 偏移(该类型的字节数 * 索引)，定位要用索引计算得到元素的内存地址，不用遍历，效率极高。如果使用内容定位，那么就要遍历每个元素的内容依次比较，效率极低。
		获取内容：使用索引直接定位该位置，拿走内容。
        遍历：容器中的元素，不管有没有顺序，我们都要不重复的将所有元素挨个摸一遍。
             从首地址开始，按顺序挨个偏移取内容
    Update：
        容器cap和len不变
        定位/修改
        
    Delete：
    	容器元素个数 -1 
    	队尾元素移除，影响最小。pop
    	remove
    		队尾 = pop
    		中间 = 后面数据统统前移
    		队首 = 后面数据统统前移
    		数据移动消耗时间，规模越大代价越大。
顺序表适合在末尾增删
在容器如果元素满了，涉及到扩容，需要在连续的存储空间后面继续扩容。如果内存碎片化严重要进行垃圾回收。如果实在扩不了，就要整体搬走。如果有就直接在后面扩容，没有就GC，还没有就整体迁移到能满足扩容后结果的地址上。
```

**顺序表定位：**

不论是链表还是顺序表，当我们定义 a = [1,2,3,4,5]  这个数组最终会存储在内存中，而a变量指向这个数组的首地址。

首地址 + 偏移（4byte * 3）

![image-20240531171150572](./../images/image-20240531171150572.png)

**顺序表插入元素图示：**

![image-20240531150009754](./../images/image-20240531150009754.png)

**顺序表删除元素图示：**

![image-20240531151039503](./../images/image-20240531151039503.png)

**扩容图示：**

![image-20240531154211972](./../images/image-20240531154211972.png)



### 8.1.2 链接表List

```ceylon
链表是个容器可以放元素。定义一个变量指向链表第一个元素地址即可。
链表看似在内存中散落无序，但链表通过双向/单项的指针来实现线性表，实现一种有序序列的物理存储。
	Create：
    	尾部追加 修改原来尾部指向新的元素，新的末尾元素指向nil，修改容器tail指向新的尾部
    	中间插入 断开两个元素的连接，两个元素分别和新元素连接相互指向，没有数据挪动，代价不大。
    	首部插入 原来第一个元素和新的首部元素互相指向，修改容器Head指向新的尾部，数据不用挪动，代价地
    Read：
    	定位:使用索引定位，因为再内存中是不连续的，所以无法使用内存偏移的方式遍历或者查找。通过haed找到首部元素，依次编索引。如果使用内容定位，那么就要遍历每个元素的内容依次比较，效率极低。通过遍历元素找到下一个元素的地址。
    	
        获取内容：
    	
    Updatae：
    	定位/更新
    	head和tail定位快
    	如果使用内容定位，需要从开头或者结尾开始，依次遍历所有内容，比较。
    	同样是利用索引，顺序表快，因为不管有多少个元素，都是一个四则公式直接推算。
    Delete
    	容器元素个数 -1 
    	末尾删除 用tail定位尾部删除末尾元素，tail指向原尾部的前一个元素，作为新tail
    	中间删除 通过遍历定位，当前元素删除，前驱元素和后继元素重新建立链接。
    	首部删除 用haed定位首部删除首部元素，head指向原首部下个元素，作为新haed。
    
链表比较适合头部和中间偶尔尾部的增删
不涉及到扩容，它不像连续表一上来就给个固定的容器不够扩容，这个散落存放只要找到一块能放元素的地方，放下之后修改链接地址即可。容量和len一致，不需要提前开辟空间，用的适合找个位置放就可以（元素和容量一样）
```



**链表使用索引定位元素：**

![image-20240601122302810](./../images/image-20240601122302810.png)

![image-20240601122326400](./../images/image-20240601122326400.png)

**链表图示：**

![image-20240531160322042](./../images/image-20240531160322042.png)

**链表新增元素：**

![image-20240601103845378](./../images/image-20240601103845378.png)



### 8.1.3 总结对比

**定位谁快：**

```
顺序表
	只知道开头的情况下，只需要明确要找那个索引，通过索引计算偏移，可以直接拿到地址取内容。
链接表
	只知道开头的情况下，需要通过开头元素指向第二个元素，再通过第二个元素拿到指向第三个元素的地址。
	说白了，只知道开头的情况下，即使有索引，也无法拿到索引对应的内容。需要通过head拿到0，再通过0拿到1，依次类推。
```

**定位问题：**

```
顺序表（Array）
顺序表，也称为数组，是一种数据结构，其中元素在内存中连续存储。每个元素都有一个索引（位置），这个索引通常是基于0的。由于元素是连续存储的，如果您知道数组的起始地址（头部）和想要访问的元素的索引，可以通过简单的数学计算（如索引乘以元素大小）直接获取到该元素的内存地址，进而访问该元素。这种方式访问速度快，时间复杂度为O(1)，但插入和删除操作可能较慢，因为可能需要移动大量元素。

链表（Linked List）
链表也是一种数据结构，与顺序表不同，链表中的元素在内存中不必连续存储。每个链表节点包含两个部分：存储数据的区域和指向下一个节点的指针。头节点（head）是链表的第一个节点，通过它开始遍历整个链表。

单向链表中，每个节点只能指向下一个节点。因此，如果只知道链表的头部，要访问特定索引的元素，确实需要从头开始，依次跟随每个节点的指针，直到达到目标索引。这意味着访问时间取决于索引的位置，最坏情况下时间复杂度为O(n)。

双向链表中，节点除了有指向下一个节点的指针外，还有指向前一个节点的指针，这可以提高某些操作的效率，但查找特定索引元素的基本过程仍然是线性的。

总结
在顺序表中，如果知道开头（即数组的基地址）和索引，可以直接计算出目标元素的地址，访问速度快。
在链表中，即使是已知开头（头节点），要访问列表中的某个特定索引位置，都需要从头开始逐个遍历节点，直到到达目标索引，这使得访问速度相对较慢，特别是对于大索引值的情况。
```





**对比习题：**

1.链接表对于增删适合吗？

```
如果增删发生在首部和中间（尾部也没问题），链接表适合，因为删除和新增元素，并不会导致大规模的数值迁移。只需要重新修改链接，修改指针地址。
如果增删频率集中再尾部，顺序表适合。因为只需要删除最后一个元素即可，不会导致数据迁移，且也不需要修改指针，也不需要修改tail指向。
```

2.手里有一个内容，我想问该线性表中有没有这个内容，用什么链表还是顺序表

```
就不该这个做，因为用内容定位查找，需要依次遍历线性表中的所有元素的内容依次对比，效率非常低。

这里不能使用二分法查找，索引有序但是我们要找的是索引中的内容。  
排序只是有顺序是序列，并不是已某种指标排序后的结果。
sequence和sort是一回事吗?
```

![image-20240601123502839](./../images/image-20240601123502839.png)

无法二分查找

![image-20240601123545166](./../images/image-20240601123545166.png)

3.我手里有索引，用什么线性表？

```
顺序表定位快
```

4.我手里有索引，要插入和删除数据，用什么线性表？

```
插入和删除连接表更合适(通用)。如果删除和增加都集中在尾部，则顺序表更合适。但插入数据要考虑到扩容问题，如果在尾部频繁插入数据，直到扩容那么顺序表就不适合，因为要扩容，涉及到数据迁移和copy,所以使用链表更合适。不过这一问题比较容易解决，在开始就定义合适大小的顺序表
```

5.增删操作随意且需要经常要使用索引定位

```
链表
```



## 8.2 数组

- **长度不可变**
- 内容可变
- 可索引
- 值类型
- 顺序表

**定义**

```go
,func main() {
    声明:
 	var a int    // 0值
    var a0 []int // 切片，0值
    var a1 [5]int // 定义数组一定要明确元素个数，0值[0 0 0]
    // var a2 [...]int  // 推导，根据元素个数推导数组容量
    var a3 = [3]int{} // 数组的字面量定义 类型:[3]int，{}表示字面量定义处,左边类型推导
    // var a4 [3]int = [3]int{} 太罗嗦
    var lang = 3
    const lang = 3
    var a5 = [lang]int{} // 变量不可以，长度可变。定义常量可以，长度确定。
   	// const a6 = [3]int 数组不能定义为常量，因为数组中的内容可以修改，无法确定。
    
    a7 := [3]int{1,2} // 元素可以小于容量，没给值用0填充，但元素不可以大于容量。
    a8 := [...]int{1,2,3} // 字面量定义用，用元素推导长度
    
    a9 := [5]int{1,2}
    fmt.Println(len(a9),cap(a9)) // array len = cap 因为定义是容量定死，元素没给0填充
    
    a10 := [5]int{0:1,2:300,4:666} // 填充指定索引值，使用索引定位
    
    二维数组
    a11 := [3][6]int{{1,2,3,4,5,6},{11,22,33,44,55,66},{1,1,1,1,1,1}} // 定义嵌套数组，外层外层数组有三个元素，三个元素又是三个数组，每个数组可以存放4个元素
    
    
    var b := [5]int{1,200,300}
    // 遍历
    fmt.printf("%p\n",&b)
    b[2] = 500  // 修改数组内元素的内容，地址并不会改变。
    for i := 0; i < len(b); i++ {
        fmt.println(i,b[i],&b[i])
    }	// 定义数组类型的变量标识符，指向的是此数组在内存中第一个元素的地址。其他元素的地址，是用元素类型所占用的空间 * 索引得到。
    b[2] = 500

    
    
    
    
    // 遍历
    for i,v := range b {
        fmt.println(i,v)
    }
    
        for _,v := range b {
        fmt.println(v)
    }
}
数组必须在编译时就确定长度，之后不能改变长度数组首地址就是数组地址所有元素一个接一个顺序存储在内存中元素的值可以改变，但是元素地址不变
```



**特殊的字符串**

```go
var c := [5]string{"zed","abc","xyz"}
for i :=0; i < len(c); i++ {
    fmt.println(i,&c[i])
}
fmt.printf("%p",&c)
// 通过遍历数组并取出地址，我发现他们的内存地址是有规律的。
0 0xc00006e050
1 0xc00006e060
2 0xc00006e070
3 0xc00006e080
4 0xc00006e090

0xc00006e050

// 然后我修改数组内容的长度,字符串的大小已超过16字节,但为什么打印的结果还是16字节一个一个的顺序存放呢？大小都以及溢出了。
var c := [5]string{"zed","abc","xyxxxxxxxxxxxxxxxxxxxxsssssssssssssssxxxxxxxxxxxxxxxxxz"}
for i :=0; i < len(c); i++ {
    fmt.println(i,&c[i])
}
fmt.printf("%p",&c)
0 0xc00006e050
1 0xc00006e060
2 0xc00006e070
3 0xc00006e080
4 0xc00006e090

0xc00006e050
```

**解释**

```
字符串是字面常量，一旦定义不可改变，不同的字符串长度不同。但是我把不同长度的字符串放在数组里面，他们的长度不一，间隔怎么划分呢?
测试后发现数组中每个字符串元素的存储单元都是16字节。实际上这16字节放的并不是字符串的内容，而是指向字符串的指针。因此string数组中存放的元素是指针，指针大小可以确定，所以是顺序存放。每个字符串自己是连续的，所有字符串元素并不能确定是连续的。
```

![image-20240601164755569](./../images/image-20240601164755569.png)









**长度和容量**

- cap即capacity，容量，表示给数组分配的内存空间可以容纳多少个元素

- len即length，长度，指的是容器中目前有几个元素

  由于数组创建时就必须确症的和len对数组来说相等。元素个数且不能改变长度所以不需要预留多杀的内存空间，因此cap

**索引**

索引从0---len -1



### 8.2.1 值类型

数组的值完全复制

用它给别的标识符赋值，会复制副本。

函数传入参数时，会复制副本。函数返回值，也是复制副本。

缺点：副本太多浪费内存，来解决这个问题：切片





## 8.3 切片slice

- 长度可变
- 内容可变
- 引用类型，和值类型不一样
- 底层基于数组，依赖于顺序表

**啥是切片：**

```apl
在Go语言中，切片（slice）是对数组的一个连续片段的引用，它提供了对数组的一个子集进行访问的功能。切片是一个引用类型，它包含了对底层数组的引用（通过指针）、切片的长度（len）和切片的容量（cap）。切片本身并不包含它所引用的底层数组的数据，但它提供了访问这些数据的方式。
```

**切片中的标头值(header)：**

```apl
指向底层数组的指针：这个指针指向了切片所引用的底层数组中的第一个元素的内存地址。通过这个指针，切片可以访问到底层数组中的数据。
长度（len）：切片的长度表示切片当前包含的元素个数。当对切片进行遍历或者索引操作时，长度决定了可以访问的元素范围。
容量（cap）：切片的容量表示从切片的起始位置到底层数组的末尾，还可以容纳的元素个数。容量决定了在不重新分配底层数组的情况下，切片可以扩展到的最大长度。
标头值的作用在于，它们提供了切片访问和操作底层数组所需的所有信息。通过这些信息，切片可以高效、安全地访问和操作底层数组中的数据。
```

**切片中存储的是什么：**

```apl
切片本身并不存储任何数据，它只存储了标头值。这些数据（即切片所引用的底层数组中的数据）实际上存储在底层数组中。切片只是通过标头值中的指针来引用这些数据。
```

**切片的地址：**

```apl
当我们谈论切片的地址时，我们实际上是指切片标头值在内存中的地址。这个地址是一个指针，它指向了存储切片标头值的内存位置。由于切片是一个引用类型，所以切片的地址通常存储在栈上（如果切片是局部变量），或者存储在堆上（如果切片是通过new关键字分配的）。通过切片的地址，我们可以访问到切片的标头值，进而访问到它所引用的底层数组中的数据。
```



```ABAP
变量被重复赋值（注意类型），变量的地址不变。
```

```go
// 不同于数组，数组在定义时必须给定长度，容量固定且不给值会默认初始化为0值。
// 切片在定义时，如果给了容量和长度也就是当前元素个数，他只会对给了元素个数的元素进行初始化，
package main

func main() {
	c := []int{10, 20, 30} // len=3 cap=3
	c1 := []int{}          // 切片字面定义 len=0 cap=0
	var c2 = []int{}
	var c3 []int // 声明c3的类型并没有赋值（没有=），所有不能写{} len=0 cap=0


	// make函数 构建切片、map、chan
	var c4 = make([]int, 1, 5)
	fmt.Printf("%d %d %d\n",c4,len(c4),cap(c4))
	
    var a5 = make([]int,1,5) // 定义切片，len 1，cap 5，第一个元素被占用，但没有给值，默认0填充
    var a6 = make([]int,0,5) // 定义切片，len 0，cap 5，容量为5，切片中一个元素都没有。
    fmt.Printf("%v %d %d %p\n",a6,len(a6),cap(a6),%a6)
    a6 = make([]int,5,5) // len 5,cap 5,重新给a6赋值，发现旧a6和新a6的地址一样。
    fmt.Printf("%v %d %d %p\n",a6,len(a6),cap(a6),%a6)
}
```



### 8.3.1 内存模型

![image-20240602163340986](./../images/image-20240602163340986.png)

```apl
1 底层数组，数组容量不可变，元素内容能变
2 slice header标头值或slice descriptor描述符
    type slice struct {
        array unsafe.Pointer // 指针，指向底层数组的首地址int
        len	// 表示当前切片的元素个数
        cap // 表示当前切片可以最多放几个元素int
        }
注意上面三个结构体的属性都是小写，所以包外不可见。1en函数取就是len属性，cap函数取cap属性

指针可以通过取底层数组的第一个元素的地址，即切片第一个元素的地址，从而获得底层数组的地址。 
	var a = []int{10,20,30}
	fmt.Printf("%v %d %d %p %p\n",a,len(a),cap(a),&a,&a[0]) // 拿到底层数组地址对比
解读:
    var a=make([lint,1,5) len=1,cap=5  打印：[0]
    var a=[]int{10,1112}
    []int 切片类型,元素有3个，len=3;cap=3  打印：[10 11 12]
    &a 表示这个切片的地址，header这个结构体的表头值。
    &a[0] 表示a1且表的第一个元素的地址，由于第一个元素存储在底层数组中，数组第一个元素地址就是数组地址
```



**解释下图：**
	我定义一个变量a0，它的类型是[]int，在内存中创建了一个切片并用a0指代这个切片的地址。这个切片中存了header，header中存了三个值，底层数组的地址、len 、cap。切片为了存储数据必须依赖底层数组。

![image-20240602113654354](./../images/image-20240602113654354.png)

**make定义图示**

​	我定义一个变量a0，它的类型是[]int，在内存中创建了一个切片并用a0指代这个切片的地址。这个切片中存了header，header中存了三个值，底层数组的地址、len 、cap。 这块连续的地，我先占上，我目前只给放了一个元素进去，没有赋初值但我表示用了一个元素，go语音没办法只能初始化为0值。其他为空值。

![image-20240602115019396](./../images/image-20240602115019396.png)



**重新赋值地址不变**

![image-20240602142804395](./../images/image-20240602142804395.png)



### 8.3.2 切片append

**代码示例:**

```go
func main() {
	a0 := []int{100} // len 1,cap 1
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0))
    a0 = make([]int,2,5) // len 2,cap 5, a0重新赋值,header内存地址不变。
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0))

    a0 = append(a0,200) // a0的容量5，目前长度2，追加第三个元素。打印:[0 0 200]，返回一个新的标头值信息 新的指针或新的len或新的cap,追加一定变的len。
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0)) // len 3,cap 5
    
    a1 := append(a0,1,2) // append操作会返回一个新的header，把返回的header赋值给新的变量a1，a1的地址和a0的地址肯定不一样，因为是重新定义变量。a0的第一个元素地址和a1的第一个元素的地址是相同的，因为底层数组一样，而且a0的len3，cap5，我加两个元素，a1变成len5，cap5。并不会引起数据迁移重新创建数组
    fmt.Printf("a1 %v %p %p;%d %d\n",a1,&a1,&a1[0],len(a1),cap(a1)) // len 5,cap 5
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0)) // len 3,cap 5 我这这里打印a0,实际上这个数组中也有后添加的1和2，只是因为截取的范围不一样所以打印结果看不到1和2。
    
    a2 := append(a0,-1)
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0)) // len 3,cap 5 
	fmt.Printf("a1 %v %p %p;%d %d\n",a1,&a1,&a1[0],len(a1),cap(a1)) // len 5,cap 5
    fmt.Printf("a2 %v %p %p;%d %d\n",a2,&a2,&a2[0],len(a2),cap(a2)) // a2是基于a0扩容，a0的len 3，cap 5,在a0的基础上增加就是第四个元素，并不会触发扩容。但由于a1以及把底层数组追加满了，只能在底层数组上修改。  打印结果是[0 0 200 -1],但这样其实会影响到a1的，[0 0 200 -1 2]
    
    a3 := append(a2,3,4,5)
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0)) // len 3,cap 5 
	fmt.Printf("a1 %v %p %p;%d %d\n",a1,&a1,&a1[0],len(a1),cap(a1)) // len 5,cap 5
    fmt.Printf("a2 %v %p %p;%d %d\n",a2,&a2,&a2[0],len(a2),cap(a2)) // len 4,cap 5
    fmt.Printf("a3 %v %p %p;%d %d\n",a3,&a3,&a3[0],len(a3),cap(a3)) // len 7,cap 10 在a2上追加三个元素，但a2 len 4,cap 5。超过了最大容量 a3 len 7,cap 5。 这次返回的标头值不仅仅len变了，cap也要变，array 指针地址也会变。因为超过了最大容量，触发扩容，go要去内存中找一块新的连续内存地址，把旧的元素copy到新的地址上，并且扩容。
    
    a4 := append(a3,11,12,13,14) // 因为a3的len 7，cap 10，追加的元素超出了最大容量，所以要生成新的底层数组。 a4 len 11,cap 20。
}
```

打印结果：

![image-20240602181831777](./../images/image-20240602181831777.png)



**图示切片追加**

```
首先定义 a0切片类型，len 1，cap 1,然后重新赋值a0 len 2，cap 5。header内存地址不变。但切片底层数组容量变大了，而且初始元素使用了两个只不过没给值。所以header值的地址不变，但beader中的array指针地址改变了。
```

![image-20240602172155814](./../images/image-20240602172155814.png)

```go
a0 = append(a0,200) // a0的容量5，目前长度2，追加第三个元素。返回一个新的标头值信息 新的指针或新的len或新的cap,追加一定变的len。打印:[0 0 200]
```

![image-20240602173041469](./../images/image-20240602173041469.png)



```go
// 由于a0和a1的len和cap不一样，就导致他们虽然是用的同一个底层数组，但显示的结果不同。
a1 := append(a0,1,2) // append操作会返回一个新的header，把返回的header赋值给新的变量a1，a1的地址和a0的地址肯定不一样，因为是重新定义变量。a0的第一个元素地址和a1的第一个元素的地址是相同的，因为底层数组一样，而且a0的len3，cap5，我加两个元素，a1变成len5，cap5。并不会引起数据迁移重新创建数组
    fmt.Printf("a1 %v %p %p;%d %d\n",a1,&a1,&a1[0],len(a1),cap(a1)) // len 5,cap 5
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0)) // len 3,cap 5 我这这里打印a0,实际上这个数组中也有后添加的1和2，只是因为截取的范围不一样所以打印结果看不到1和2。
```

![image-20240602174705458](./../images/image-20240602174705458.png)

```go
    a2 := append(a0,-1)
    fmt.Printf("a0 %v %p %p;%d %d\n",a0,&a0,&a0[0],len(a0),cap(a0)) // len 3,cap 5 
	fmt.Printf("a1 %v %p %p;%d %d\n",a1,&a1,&a1[0],len(a1),cap(a1)) // len 5,cap 5
    fmt.Printf("a2 %v %p %p;%d %d\n",a2,&a2,&a2[0],len(a2),cap(a2)) // a2是基于a0扩容，a0的len 3，cap 5,在a0的基础上增加就是第四个元素，并不会触发扩容。但由于a1以及把底层数组追加满了，只能在底层数组上修改。  打印结果是[0 0 200 -1],但这样其实会影响到a1的，[0 0 200 -1 2]
总结：
如果多个切片共用一个底层数组，而且数组刚好满了无法追加，会触发扩容。但这时候我用其他容量没满的切片append，会导致数据被覆盖/修改/
```



![image-20240602175730751](./../images/image-20240602175730751.png)



**超过最大容量，底层数组地址变了**

```
a3 := append(a2,3,4,5)
因为是基于a2追加，a2 len 4，cap5。所以并没有复制原来的2到新的数组
```

![image-20240602180825086](./../images/image-20240602180825086.png)

![image-20240602181318256](./../images/image-20240602181318256.png)



![image-20240602151648953](./../images/image-20240602151648953.png)

**扩容策略**

![image-20240602182231965](./../images/image-20240602182231965.png)
